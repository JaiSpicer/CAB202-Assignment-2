   1               		.file	"hero.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__eqsf2
  11               	.global	__addsf3
  12               	.global	__floatsisf
  13               	.global	__gesf2
  14               	.global	__ltsf2
  15               		.section	.text.move_hero,"ax",@progbits
  16               	.global	move_hero
  18               	move_hero:
  19               	.LFB8:
  20               		.file 1 "hero.c"
   1:hero.c        **** /*
   2:hero.c        ****  * hero.c
   3:hero.c        ****  *
   4:hero.c        ****  *  Created on: 8 May 2015
   5:hero.c        ****  *      Author: Jai Spicer
   6:hero.c        ****  */
   7:hero.c        **** #include <util/delay.h>
   8:hero.c        **** 
   9:hero.c        **** #include "sprite.h"
  10:hero.c        **** #include "graphics.h"
  11:hero.c        **** #include "friendly_ports.h"
  12:hero.c        **** 
  13:hero.c        **** #include "start_screen.h"
  14:hero.c        **** #include "screen.h"
  15:hero.c        **** #include "lives.h"
  16:hero.c        **** #include "score.h"
  17:hero.c        **** #include "hero.h"
  18:hero.c        **** #include "zombies.h"
  19:hero.c        **** #include "pit.h"
  20:hero.c        **** #include "items.h"
  21:hero.c        **** 
  22:hero.c        **** int px = 1;
  23:hero.c        **** int py = 0;
  24:hero.c        **** 
  25:hero.c        **** void start_hero() {
  26:hero.c        **** 	byte bitmap_hero[] = {
  27:hero.c        **** 			BYTE( 11100000 ),
  28:hero.c        **** 			BYTE( 01000000 ),
  29:hero.c        **** 			BYTE( 11100000 )
  30:hero.c        **** 	};
  31:hero.c        **** 
  32:hero.c        **** 	const int hero_width = 3; // Maybe 4
  33:hero.c        **** 	const int hero_height = 3;
  34:hero.c        **** 
  35:hero.c        **** 	Sprite hero;
  36:hero.c        **** 
  37:hero.c        **** 	init_sprite( &hero, 38,28,hero_width,hero_height, bitmap_hero );
  38:hero.c        **** 	hero.dx = 1;
  39:hero.c        **** 	hero.dy = 0;
  40:hero.c        **** 
  41:hero.c        **** 	draw_sprite( &hero );
  42:hero.c        **** 	int zombie_update = 0;
  43:hero.c        **** 	int score_update = 0;
  44:hero.c        **** 	while (1) {
  45:hero.c        **** 		clear();
  46:hero.c        **** 		screen_lines();
  47:hero.c        ****     	lives_setup();
  48:hero.c        ****     	score_setup();
  49:hero.c        **** 
  50:hero.c        **** //    	start_pit();
  51:hero.c        **** //    	sword_setup();
  52:hero.c        **** //    	grenades_setup();
  53:hero.c        **** 
  54:hero.c        **** 		move_hero( &hero );
  55:hero.c        **** 		draw_sprite (&hero );
  56:hero.c        **** 		if ( zombie_update == 10 ) {
  57:hero.c        **** 			new_zombies_pos();
  58:hero.c        **** //			start_zombies();
  59:hero.c        **** 			zombie_update = 0;
  60:hero.c        **** 		}
  61:hero.c        **** 		if ( score_update == 50 ) {
  62:hero.c        **** 			update_score_time();
  63:hero.c        **** 			score_update = 0;
  64:hero.c        **** 		}
  65:hero.c        **** 		refresh();
  66:hero.c        **** 		zombie_update++;
  67:hero.c        **** 		score_update++;
  68:hero.c        **** 		_delay_ms( 100 );
  69:hero.c        **** 	}
  70:hero.c        **** 
  71:hero.c        **** }
  72:hero.c        **** 
  73:hero.c        **** void move_hero( Sprite * hero ) {
  21               		.loc 1 73 0
  22               		.cfi_startproc
  23               	.LVL0:
  24 0000 AF92      		push r10
  25               	.LCFI0:
  26               		.cfi_def_cfa_offset 3
  27               		.cfi_offset 10, -2
  28 0002 BF92      		push r11
  29               	.LCFI1:
  30               		.cfi_def_cfa_offset 4
  31               		.cfi_offset 11, -3
  32 0004 CF92      		push r12
  33               	.LCFI2:
  34               		.cfi_def_cfa_offset 5
  35               		.cfi_offset 12, -4
  36 0006 DF92      		push r13
  37               	.LCFI3:
  38               		.cfi_def_cfa_offset 6
  39               		.cfi_offset 13, -5
  40 0008 EF92      		push r14
  41               	.LCFI4:
  42               		.cfi_def_cfa_offset 7
  43               		.cfi_offset 14, -6
  44 000a FF92      		push r15
  45               	.LCFI5:
  46               		.cfi_def_cfa_offset 8
  47               		.cfi_offset 15, -7
  48 000c 0F93      		push r16
  49               	.LCFI6:
  50               		.cfi_def_cfa_offset 9
  51               		.cfi_offset 16, -8
  52 000e 1F93      		push r17
  53               	.LCFI7:
  54               		.cfi_def_cfa_offset 10
  55               		.cfi_offset 17, -9
  56 0010 CF93      		push r28
  57               	.LCFI8:
  58               		.cfi_def_cfa_offset 11
  59               		.cfi_offset 28, -10
  60 0012 DF93      		push r29
  61               	.LCFI9:
  62               		.cfi_def_cfa_offset 12
  63               		.cfi_offset 29, -11
  64               	/* prologue: function */
  65               	/* frame size = 0 */
  66               	/* stack size = 10 */
  67               	.L__stack_usage = 10
  68 0014 EC01      		movw r28,r24
  74:hero.c        **** 
  75:hero.c        **** 	if ( ( hero->dx == 1) && ( pressed ( SW1 ) ) ) { // Right Button, turn right, down
  69               		.loc 1 75 0
  70 0016 20E0      		ldi r18,0
  71 0018 30E0      		ldi r19,0
  72 001a 40E8      		ldi r20,lo8(-128)
  73 001c 5FE3      		ldi r21,lo8(63)
  74 001e 6D85      		ldd r22,Y+13
  75 0020 7E85      		ldd r23,Y+14
  76 0022 8F85      		ldd r24,Y+15
  77 0024 9889      		ldd r25,Y+16
  78 0026 0E94 0000 		call __eqsf2
  79               	.LVL1:
  80 002a 8111      		cpse r24,__zero_reg__
  81 002c 00C0      		rjmp .L2
  82               		.loc 1 75 0 is_stmt 0 discriminator 1
  83 002e 199B      		sbis 0x3,1
  84 0030 00C0      		rjmp .L2
  85               	.LVL2:
  86               	.LBB21:
  87               	.LBB22:
  88               		.file 2 "/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h"
   1:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  89               		.loc 2 164 0 is_stmt 1
  90 0032 2FEF      		ldi r18,lo8(159999)
  91 0034 80E7      		ldi r24,hi8(159999)
  92 0036 92E0      		ldi r25,hlo8(159999)
  93 0038 2150      		1: subi r18,1
  94 003a 8040      		sbci r24,0
  95 003c 9040      		sbci r25,0
  96 003e 01F4      		brne 1b
  97 0040 00C0      		rjmp .
  98 0042 0000      		nop
  99               	.LBE22:
 100               	.LBE21:
  76:hero.c        **** 		_delay_ms(100);
  77:hero.c        **** 		hero->dx = 0;
 101               		.loc 1 77 0
 102 0044 1D86      		std Y+13,__zero_reg__
 103 0046 1E86      		std Y+14,__zero_reg__
 104 0048 1F86      		std Y+15,__zero_reg__
 105 004a 188A      		std Y+16,__zero_reg__
  78:hero.c        **** 		hero->dy = 1;
 106               		.loc 1 78 0
 107 004c 80E0      		ldi r24,0
 108 004e 90E0      		ldi r25,0
 109 0050 A0E8      		ldi r26,lo8(-128)
 110 0052 BFE3      		ldi r27,lo8(63)
 111 0054 898B      		std Y+17,r24
 112 0056 9A8B      		std Y+18,r25
 113 0058 AB8B      		std Y+19,r26
 114 005a BC8B      		std Y+20,r27
  79:hero.c        **** 		px = 0;
 115               		.loc 1 79 0
 116 005c 1092 0000 		sts px+1,__zero_reg__
 117 0060 1092 0000 		sts px,__zero_reg__
  80:hero.c        **** 		py = 1;
 118               		.loc 1 80 0
 119 0064 81E0      		ldi r24,lo8(1)
 120 0066 90E0      		ldi r25,0
 121 0068 9093 0000 		sts py+1,r25
 122 006c 8093 0000 		sts py,r24
 123               	.LVL3:
 124               	.L2:
  81:hero.c        **** 	}
  82:hero.c        **** 	if ( (hero->dx == -1) && ( pressed ( SW1 ) )) { // Right Button, turn right, up
 125               		.loc 1 82 0
 126 0070 20E0      		ldi r18,0
 127 0072 30E0      		ldi r19,0
 128 0074 40E8      		ldi r20,lo8(-128)
 129 0076 5FEB      		ldi r21,lo8(-65)
 130 0078 6D85      		ldd r22,Y+13
 131 007a 7E85      		ldd r23,Y+14
 132 007c 8F85      		ldd r24,Y+15
 133 007e 9889      		ldd r25,Y+16
 134 0080 0E94 0000 		call __eqsf2
 135               	.LVL4:
 136 0084 8111      		cpse r24,__zero_reg__
 137 0086 00C0      		rjmp .L4
 138               		.loc 1 82 0 is_stmt 0 discriminator 1
 139 0088 199B      		sbis 0x3,1
 140 008a 00C0      		rjmp .L4
 141               	.LVL5:
 142               	.LBB23:
 143               	.LBB24:
 144               		.loc 2 164 0 is_stmt 1
 145 008c 2FEF      		ldi r18,lo8(159999)
 146 008e 80E7      		ldi r24,hi8(159999)
 147 0090 92E0      		ldi r25,hlo8(159999)
 148 0092 2150      		1: subi r18,1
 149 0094 8040      		sbci r24,0
 150 0096 9040      		sbci r25,0
 151 0098 01F4      		brne 1b
 152 009a 00C0      		rjmp .
 153 009c 0000      		nop
 154               	.LBE24:
 155               	.LBE23:
  83:hero.c        **** 		_delay_ms(100);
  84:hero.c        **** 		hero->dx = 0;
 156               		.loc 1 84 0
 157 009e 1D86      		std Y+13,__zero_reg__
 158 00a0 1E86      		std Y+14,__zero_reg__
 159 00a2 1F86      		std Y+15,__zero_reg__
 160 00a4 188A      		std Y+16,__zero_reg__
  85:hero.c        **** 		hero->dy = -1;
 161               		.loc 1 85 0
 162 00a6 80E0      		ldi r24,0
 163 00a8 90E0      		ldi r25,0
 164 00aa A0E8      		ldi r26,lo8(-128)
 165 00ac BFEB      		ldi r27,lo8(-65)
 166 00ae 898B      		std Y+17,r24
 167 00b0 9A8B      		std Y+18,r25
 168 00b2 AB8B      		std Y+19,r26
 169 00b4 BC8B      		std Y+20,r27
  86:hero.c        **** 		px = 0;
 170               		.loc 1 86 0
 171 00b6 1092 0000 		sts px+1,__zero_reg__
 172 00ba 1092 0000 		sts px,__zero_reg__
  87:hero.c        **** 		py = -1;
 173               		.loc 1 87 0
 174 00be 8FEF      		ldi r24,lo8(-1)
 175 00c0 9FEF      		ldi r25,lo8(-1)
 176 00c2 9093 0000 		sts py+1,r25
 177 00c6 8093 0000 		sts py,r24
 178               	.LVL6:
 179               	.L4:
  88:hero.c        **** 	}
  89:hero.c        **** 	if ( ( hero->dy == 1 ) && ( pressed ( SW1 ) )) { // Right Button, turn right, left
 180               		.loc 1 89 0
 181 00ca 20E0      		ldi r18,0
 182 00cc 30E0      		ldi r19,0
 183 00ce 40E8      		ldi r20,lo8(-128)
 184 00d0 5FE3      		ldi r21,lo8(63)
 185 00d2 6989      		ldd r22,Y+17
 186 00d4 7A89      		ldd r23,Y+18
 187 00d6 8B89      		ldd r24,Y+19
 188 00d8 9C89      		ldd r25,Y+20
 189 00da 0E94 0000 		call __eqsf2
 190               	.LVL7:
 191 00de 8111      		cpse r24,__zero_reg__
 192 00e0 00C0      		rjmp .L6
 193               		.loc 1 89 0 is_stmt 0 discriminator 1
 194 00e2 199B      		sbis 0x3,1
 195 00e4 00C0      		rjmp .L6
 196               	.LVL8:
 197               	.LBB25:
 198               	.LBB26:
 199               		.loc 2 164 0 is_stmt 1
 200 00e6 2FEF      		ldi r18,lo8(159999)
 201 00e8 80E7      		ldi r24,hi8(159999)
 202 00ea 92E0      		ldi r25,hlo8(159999)
 203 00ec 2150      		1: subi r18,1
 204 00ee 8040      		sbci r24,0
 205 00f0 9040      		sbci r25,0
 206 00f2 01F4      		brne 1b
 207 00f4 00C0      		rjmp .
 208 00f6 0000      		nop
 209               	.LBE26:
 210               	.LBE25:
  90:hero.c        **** 		_delay_ms(100);
  91:hero.c        **** 		hero->dx = -1;
 211               		.loc 1 91 0
 212 00f8 80E0      		ldi r24,0
 213 00fa 90E0      		ldi r25,0
 214 00fc A0E8      		ldi r26,lo8(-128)
 215 00fe BFEB      		ldi r27,lo8(-65)
 216 0100 8D87      		std Y+13,r24
 217 0102 9E87      		std Y+14,r25
 218 0104 AF87      		std Y+15,r26
 219 0106 B88B      		std Y+16,r27
  92:hero.c        **** 		hero->dy = 0;
 220               		.loc 1 92 0
 221 0108 198A      		std Y+17,__zero_reg__
 222 010a 1A8A      		std Y+18,__zero_reg__
 223 010c 1B8A      		std Y+19,__zero_reg__
 224 010e 1C8A      		std Y+20,__zero_reg__
  93:hero.c        **** 		px = -1;
 225               		.loc 1 93 0
 226 0110 8FEF      		ldi r24,lo8(-1)
 227 0112 9FEF      		ldi r25,lo8(-1)
 228 0114 9093 0000 		sts px+1,r25
 229 0118 8093 0000 		sts px,r24
  94:hero.c        **** 		py = 0;
 230               		.loc 1 94 0
 231 011c 1092 0000 		sts py+1,__zero_reg__
 232 0120 1092 0000 		sts py,__zero_reg__
 233               	.LVL9:
 234               	.L6:
  95:hero.c        **** 	}
  96:hero.c        **** 	if ( ( hero->dy == -1 ) && ( pressed ( SW1 ) )) { // Right Button, turn right , right
 235               		.loc 1 96 0
 236 0124 20E0      		ldi r18,0
 237 0126 30E0      		ldi r19,0
 238 0128 40E8      		ldi r20,lo8(-128)
 239 012a 5FEB      		ldi r21,lo8(-65)
 240 012c 6989      		ldd r22,Y+17
 241 012e 7A89      		ldd r23,Y+18
 242 0130 8B89      		ldd r24,Y+19
 243 0132 9C89      		ldd r25,Y+20
 244 0134 0E94 0000 		call __eqsf2
 245               	.LVL10:
 246 0138 8111      		cpse r24,__zero_reg__
 247 013a 00C0      		rjmp .L8
 248               		.loc 1 96 0 is_stmt 0 discriminator 1
 249 013c 199B      		sbis 0x3,1
 250 013e 00C0      		rjmp .L8
 251               	.LVL11:
 252               	.LBB27:
 253               	.LBB28:
 254               		.loc 2 164 0 is_stmt 1
 255 0140 2FEF      		ldi r18,lo8(159999)
 256 0142 80E7      		ldi r24,hi8(159999)
 257 0144 92E0      		ldi r25,hlo8(159999)
 258 0146 2150      		1: subi r18,1
 259 0148 8040      		sbci r24,0
 260 014a 9040      		sbci r25,0
 261 014c 01F4      		brne 1b
 262 014e 00C0      		rjmp .
 263 0150 0000      		nop
 264               	.LBE28:
 265               	.LBE27:
  97:hero.c        **** 		_delay_ms(100);
  98:hero.c        **** 		hero->dx = 1;
 266               		.loc 1 98 0
 267 0152 80E0      		ldi r24,0
 268 0154 90E0      		ldi r25,0
 269 0156 A0E8      		ldi r26,lo8(-128)
 270 0158 BFE3      		ldi r27,lo8(63)
 271 015a 8D87      		std Y+13,r24
 272 015c 9E87      		std Y+14,r25
 273 015e AF87      		std Y+15,r26
 274 0160 B88B      		std Y+16,r27
  99:hero.c        **** 		hero->dy = 0;
 275               		.loc 1 99 0
 276 0162 198A      		std Y+17,__zero_reg__
 277 0164 1A8A      		std Y+18,__zero_reg__
 278 0166 1B8A      		std Y+19,__zero_reg__
 279 0168 1C8A      		std Y+20,__zero_reg__
 100:hero.c        **** 		px = 1;
 280               		.loc 1 100 0
 281 016a 81E0      		ldi r24,lo8(1)
 282 016c 90E0      		ldi r25,0
 283 016e 9093 0000 		sts px+1,r25
 284 0172 8093 0000 		sts px,r24
 101:hero.c        **** 		py = 0;
 285               		.loc 1 101 0
 286 0176 1092 0000 		sts py+1,__zero_reg__
 287 017a 1092 0000 		sts py,__zero_reg__
 288               	.LVL12:
 289               	.L8:
 102:hero.c        **** 	}
 103:hero.c        **** 	if ( ( hero->dx == 1 ) && ( pressed ( SW0 ) )) { // Left Button, turn left, up
 290               		.loc 1 103 0
 291 017e 20E0      		ldi r18,0
 292 0180 30E0      		ldi r19,0
 293 0182 40E8      		ldi r20,lo8(-128)
 294 0184 5FE3      		ldi r21,lo8(63)
 295 0186 6D85      		ldd r22,Y+13
 296 0188 7E85      		ldd r23,Y+14
 297 018a 8F85      		ldd r24,Y+15
 298 018c 9889      		ldd r25,Y+16
 299 018e 0E94 0000 		call __eqsf2
 300               	.LVL13:
 301 0192 8111      		cpse r24,__zero_reg__
 302 0194 00C0      		rjmp .L10
 303               		.loc 1 103 0 is_stmt 0 discriminator 1
 304 0196 189B      		sbis 0x3,0
 305 0198 00C0      		rjmp .L10
 306               	.LVL14:
 307               	.LBB29:
 308               	.LBB30:
 309               		.loc 2 164 0 is_stmt 1
 310 019a 2FEF      		ldi r18,lo8(159999)
 311 019c 80E7      		ldi r24,hi8(159999)
 312 019e 92E0      		ldi r25,hlo8(159999)
 313 01a0 2150      		1: subi r18,1
 314 01a2 8040      		sbci r24,0
 315 01a4 9040      		sbci r25,0
 316 01a6 01F4      		brne 1b
 317 01a8 00C0      		rjmp .
 318 01aa 0000      		nop
 319               	.LBE30:
 320               	.LBE29:
 104:hero.c        **** 		_delay_ms(100);
 105:hero.c        **** 		hero->dx = 0;
 321               		.loc 1 105 0
 322 01ac 1D86      		std Y+13,__zero_reg__
 323 01ae 1E86      		std Y+14,__zero_reg__
 324 01b0 1F86      		std Y+15,__zero_reg__
 325 01b2 188A      		std Y+16,__zero_reg__
 106:hero.c        **** 		hero->dy = -1;
 326               		.loc 1 106 0
 327 01b4 80E0      		ldi r24,0
 328 01b6 90E0      		ldi r25,0
 329 01b8 A0E8      		ldi r26,lo8(-128)
 330 01ba BFEB      		ldi r27,lo8(-65)
 331 01bc 898B      		std Y+17,r24
 332 01be 9A8B      		std Y+18,r25
 333 01c0 AB8B      		std Y+19,r26
 334 01c2 BC8B      		std Y+20,r27
 107:hero.c        **** 		px = 0;
 335               		.loc 1 107 0
 336 01c4 1092 0000 		sts px+1,__zero_reg__
 337 01c8 1092 0000 		sts px,__zero_reg__
 108:hero.c        **** 		py = -1;
 338               		.loc 1 108 0
 339 01cc 8FEF      		ldi r24,lo8(-1)
 340 01ce 9FEF      		ldi r25,lo8(-1)
 341 01d0 9093 0000 		sts py+1,r25
 342 01d4 8093 0000 		sts py,r24
 343               	.LVL15:
 344               	.L10:
 109:hero.c        **** 	}
 110:hero.c        **** 	if ( ( hero->dx == -1 ) && ( pressed ( SW0 ) )) { // Left Button, turn left, down
 345               		.loc 1 110 0
 346 01d8 20E0      		ldi r18,0
 347 01da 30E0      		ldi r19,0
 348 01dc 40E8      		ldi r20,lo8(-128)
 349 01de 5FEB      		ldi r21,lo8(-65)
 350 01e0 6D85      		ldd r22,Y+13
 351 01e2 7E85      		ldd r23,Y+14
 352 01e4 8F85      		ldd r24,Y+15
 353 01e6 9889      		ldd r25,Y+16
 354 01e8 0E94 0000 		call __eqsf2
 355               	.LVL16:
 356 01ec 8111      		cpse r24,__zero_reg__
 357 01ee 00C0      		rjmp .L12
 358               		.loc 1 110 0 is_stmt 0 discriminator 1
 359 01f0 189B      		sbis 0x3,0
 360 01f2 00C0      		rjmp .L12
 361               	.LVL17:
 362               	.LBB31:
 363               	.LBB32:
 364               		.loc 2 164 0 is_stmt 1
 365 01f4 2FEF      		ldi r18,lo8(159999)
 366 01f6 80E7      		ldi r24,hi8(159999)
 367 01f8 92E0      		ldi r25,hlo8(159999)
 368 01fa 2150      		1: subi r18,1
 369 01fc 8040      		sbci r24,0
 370 01fe 9040      		sbci r25,0
 371 0200 01F4      		brne 1b
 372 0202 00C0      		rjmp .
 373 0204 0000      		nop
 374               	.LBE32:
 375               	.LBE31:
 111:hero.c        **** 		_delay_ms(100);
 112:hero.c        **** 		hero->dx = 0;
 376               		.loc 1 112 0
 377 0206 1D86      		std Y+13,__zero_reg__
 378 0208 1E86      		std Y+14,__zero_reg__
 379 020a 1F86      		std Y+15,__zero_reg__
 380 020c 188A      		std Y+16,__zero_reg__
 113:hero.c        **** 		hero->dy = 1;
 381               		.loc 1 113 0
 382 020e 80E0      		ldi r24,0
 383 0210 90E0      		ldi r25,0
 384 0212 A0E8      		ldi r26,lo8(-128)
 385 0214 BFE3      		ldi r27,lo8(63)
 386 0216 898B      		std Y+17,r24
 387 0218 9A8B      		std Y+18,r25
 388 021a AB8B      		std Y+19,r26
 389 021c BC8B      		std Y+20,r27
 114:hero.c        **** 		px = 0;
 390               		.loc 1 114 0
 391 021e 1092 0000 		sts px+1,__zero_reg__
 392 0222 1092 0000 		sts px,__zero_reg__
 115:hero.c        **** 		py = 1;
 393               		.loc 1 115 0
 394 0226 81E0      		ldi r24,lo8(1)
 395 0228 90E0      		ldi r25,0
 396 022a 9093 0000 		sts py+1,r25
 397 022e 8093 0000 		sts py,r24
 398               	.LVL18:
 399               	.L12:
 116:hero.c        **** 	}
 117:hero.c        **** 	if ( ( hero->dy == 1 ) && ( pressed ( SW0 ) )) { // Left Button, turn left, right
 400               		.loc 1 117 0
 401 0232 20E0      		ldi r18,0
 402 0234 30E0      		ldi r19,0
 403 0236 40E8      		ldi r20,lo8(-128)
 404 0238 5FE3      		ldi r21,lo8(63)
 405 023a 6989      		ldd r22,Y+17
 406 023c 7A89      		ldd r23,Y+18
 407 023e 8B89      		ldd r24,Y+19
 408 0240 9C89      		ldd r25,Y+20
 409 0242 0E94 0000 		call __eqsf2
 410               	.LVL19:
 411 0246 8111      		cpse r24,__zero_reg__
 412 0248 00C0      		rjmp .L14
 413               		.loc 1 117 0 is_stmt 0 discriminator 1
 414 024a 189B      		sbis 0x3,0
 415 024c 00C0      		rjmp .L14
 416               	.LVL20:
 417               	.LBB33:
 418               	.LBB34:
 419               		.loc 2 164 0 is_stmt 1
 420 024e 2FEF      		ldi r18,lo8(159999)
 421 0250 80E7      		ldi r24,hi8(159999)
 422 0252 92E0      		ldi r25,hlo8(159999)
 423 0254 2150      		1: subi r18,1
 424 0256 8040      		sbci r24,0
 425 0258 9040      		sbci r25,0
 426 025a 01F4      		brne 1b
 427 025c 00C0      		rjmp .
 428 025e 0000      		nop
 429               	.LBE34:
 430               	.LBE33:
 118:hero.c        **** 		_delay_ms(100);
 119:hero.c        **** 		hero->dx = 1;
 431               		.loc 1 119 0
 432 0260 80E0      		ldi r24,0
 433 0262 90E0      		ldi r25,0
 434 0264 A0E8      		ldi r26,lo8(-128)
 435 0266 BFE3      		ldi r27,lo8(63)
 436 0268 8D87      		std Y+13,r24
 437 026a 9E87      		std Y+14,r25
 438 026c AF87      		std Y+15,r26
 439 026e B88B      		std Y+16,r27
 120:hero.c        **** 		hero->dy = 0;
 440               		.loc 1 120 0
 441 0270 198A      		std Y+17,__zero_reg__
 442 0272 1A8A      		std Y+18,__zero_reg__
 443 0274 1B8A      		std Y+19,__zero_reg__
 444 0276 1C8A      		std Y+20,__zero_reg__
 121:hero.c        **** 		px = 1;
 445               		.loc 1 121 0
 446 0278 81E0      		ldi r24,lo8(1)
 447 027a 90E0      		ldi r25,0
 448 027c 9093 0000 		sts px+1,r25
 449 0280 8093 0000 		sts px,r24
 122:hero.c        **** 		py = 0;
 450               		.loc 1 122 0
 451 0284 1092 0000 		sts py+1,__zero_reg__
 452 0288 1092 0000 		sts py,__zero_reg__
 453               	.LVL21:
 454               	.L14:
 123:hero.c        **** 	}
 124:hero.c        **** 	if ( ( hero->dy == -1 ) && ( pressed ( SW0 ) )) { // Left Button, turn left, left
 455               		.loc 1 124 0
 456 028c 20E0      		ldi r18,0
 457 028e 30E0      		ldi r19,0
 458 0290 40E8      		ldi r20,lo8(-128)
 459 0292 5FEB      		ldi r21,lo8(-65)
 460 0294 6989      		ldd r22,Y+17
 461 0296 7A89      		ldd r23,Y+18
 462 0298 8B89      		ldd r24,Y+19
 463 029a 9C89      		ldd r25,Y+20
 464 029c 0E94 0000 		call __eqsf2
 465               	.LVL22:
 466 02a0 8111      		cpse r24,__zero_reg__
 467 02a2 00C0      		rjmp .L16
 468               		.loc 1 124 0 is_stmt 0 discriminator 1
 469 02a4 189B      		sbis 0x3,0
 470 02a6 00C0      		rjmp .L16
 471               	.LVL23:
 472               	.LBB35:
 473               	.LBB36:
 474               		.loc 2 164 0 is_stmt 1
 475 02a8 2FEF      		ldi r18,lo8(159999)
 476 02aa 80E7      		ldi r24,hi8(159999)
 477 02ac 92E0      		ldi r25,hlo8(159999)
 478 02ae 2150      		1: subi r18,1
 479 02b0 8040      		sbci r24,0
 480 02b2 9040      		sbci r25,0
 481 02b4 01F4      		brne 1b
 482 02b6 00C0      		rjmp .
 483 02b8 0000      		nop
 484               	.LBE36:
 485               	.LBE35:
 125:hero.c        **** 		_delay_ms(100);
 126:hero.c        **** 		hero->dx = -1;
 486               		.loc 1 126 0
 487 02ba 80E0      		ldi r24,0
 488 02bc 90E0      		ldi r25,0
 489 02be A0E8      		ldi r26,lo8(-128)
 490 02c0 BFEB      		ldi r27,lo8(-65)
 491 02c2 8D87      		std Y+13,r24
 492 02c4 9E87      		std Y+14,r25
 493 02c6 AF87      		std Y+15,r26
 494 02c8 B88B      		std Y+16,r27
 127:hero.c        **** 		hero->dy = 0;
 495               		.loc 1 127 0
 496 02ca 198A      		std Y+17,__zero_reg__
 497 02cc 1A8A      		std Y+18,__zero_reg__
 498 02ce 1B8A      		std Y+19,__zero_reg__
 499 02d0 1C8A      		std Y+20,__zero_reg__
 128:hero.c        **** 		px = -1;
 500               		.loc 1 128 0
 501 02d2 8FEF      		ldi r24,lo8(-1)
 502 02d4 9FEF      		ldi r25,lo8(-1)
 503 02d6 9093 0000 		sts px+1,r25
 504 02da 8093 0000 		sts px,r24
 129:hero.c        **** 		py = 0;
 505               		.loc 1 129 0
 506 02de 1092 0000 		sts py+1,__zero_reg__
 507 02e2 1092 0000 		sts py,__zero_reg__
 508               	.LVL24:
 509               	.L16:
 130:hero.c        **** 	}
 131:hero.c        **** 
 132:hero.c        **** 	hero->x += hero->dx;
 510               		.loc 1 132 0
 511 02e6 2D85      		ldd r18,Y+13
 512 02e8 3E85      		ldd r19,Y+14
 513 02ea 4F85      		ldd r20,Y+15
 514 02ec 5889      		ldd r21,Y+16
 515 02ee 6881      		ld r22,Y
 516 02f0 7981      		ldd r23,Y+1
 517 02f2 8A81      		ldd r24,Y+2
 518 02f4 9B81      		ldd r25,Y+3
 519 02f6 0E94 0000 		call __addsf3
 520               	.LVL25:
 521 02fa 5B01      		movw r10,r22
 522 02fc 6C01      		movw r12,r24
 523 02fe 862F      		mov r24,r22
 524 0300 9B2D      		mov r25,r11
 525 0302 AC2D      		mov r26,r12
 526 0304 BD2D      		mov r27,r13
 527 0306 8883      		st Y,r24
 528 0308 9983      		std Y+1,r25
 529 030a AA83      		std Y+2,r26
 530 030c BB83      		std Y+3,r27
 133:hero.c        **** 	hero->y += hero->dy;
 531               		.loc 1 133 0
 532 030e 2989      		ldd r18,Y+17
 533 0310 3A89      		ldd r19,Y+18
 534 0312 4B89      		ldd r20,Y+19
 535 0314 5C89      		ldd r21,Y+20
 536 0316 6C81      		ldd r22,Y+4
 537 0318 7D81      		ldd r23,Y+5
 538 031a 8E81      		ldd r24,Y+6
 539 031c 9F81      		ldd r25,Y+7
 540 031e 0E94 0000 		call __addsf3
 541               	.LVL26:
 542 0322 7B01      		movw r14,r22
 543 0324 8C01      		movw r16,r24
 544 0326 982F      		mov r25,r24
 545 0328 4E2D      		mov r20,r14
 546 032a 5F2D      		mov r21,r15
 547 032c 692F      		mov r22,r25
 548 032e 712F      		mov r23,r17
 549 0330 4C83      		std Y+4,r20
 550 0332 5D83      		std Y+5,r21
 551 0334 6E83      		std Y+6,r22
 552 0336 7F83      		std Y+7,r23
 134:hero.c        **** 
 135:hero.c        **** 	if ( hero->x >= (LCD_X - 1) - hero->width || hero->x < 2 ) {
 553               		.loc 1 135 0
 554 0338 8885      		ldd r24,Y+8
 555 033a 63E5      		ldi r22,lo8(83)
 556 033c 70E0      		ldi r23,0
 557 033e 681B      		sub r22,r24
 558 0340 7109      		sbc r23,__zero_reg__
 559 0342 8827      		clr r24
 560 0344 77FD      		sbrc r23,7
 561 0346 8095      		com r24
 562 0348 982F      		mov r25,r24
 563 034a 0E94 0000 		call __floatsisf
 564               	.LVL27:
 565 034e 9B01      		movw r18,r22
 566 0350 AC01      		movw r20,r24
 567 0352 6A2D      		mov r22,r10
 568 0354 7B2D      		mov r23,r11
 569 0356 8C2D      		mov r24,r12
 570 0358 9D2D      		mov r25,r13
 571 035a 0E94 0000 		call __gesf2
 572               	.LVL28:
 573 035e 87FF      		sbrs r24,7
 574 0360 00C0      		rjmp .L18
 575               		.loc 1 135 0 is_stmt 0 discriminator 1
 576 0362 20E0      		ldi r18,0
 577 0364 30E0      		ldi r19,0
 578 0366 40E0      		ldi r20,0
 579 0368 50E4      		ldi r21,lo8(64)
 580 036a 6A2D      		mov r22,r10
 581 036c 7B2D      		mov r23,r11
 582 036e 8C2D      		mov r24,r12
 583 0370 9D2D      		mov r25,r13
 584 0372 0E94 0000 		call __ltsf2
 585               	.LVL29:
 586 0376 87FF      		sbrs r24,7
 587 0378 00C0      		rjmp .L19
 588               	.L18:
 136:hero.c        **** 		hero->dx = 0;
 589               		.loc 1 136 0 is_stmt 1
 590 037a 1D86      		std Y+13,__zero_reg__
 591 037c 1E86      		std Y+14,__zero_reg__
 592 037e 1F86      		std Y+15,__zero_reg__
 593 0380 188A      		std Y+16,__zero_reg__
 594               	.L19:
 137:hero.c        **** 	}
 138:hero.c        **** 
 139:hero.c        **** 	if ( hero->y >= (LCD_Y - 1) - hero->height || hero->y < 14 ) {
 595               		.loc 1 139 0
 596 0382 8985      		ldd r24,Y+9
 597 0384 6FE2      		ldi r22,lo8(47)
 598 0386 70E0      		ldi r23,0
 599 0388 681B      		sub r22,r24
 600 038a 7109      		sbc r23,__zero_reg__
 601 038c 8827      		clr r24
 602 038e 77FD      		sbrc r23,7
 603 0390 8095      		com r24
 604 0392 982F      		mov r25,r24
 605 0394 0E94 0000 		call __floatsisf
 606               	.LVL30:
 607 0398 9B01      		movw r18,r22
 608 039a AC01      		movw r20,r24
 609 039c 6E2D      		mov r22,r14
 610 039e 7F2D      		mov r23,r15
 611 03a0 802F      		mov r24,r16
 612 03a2 912F      		mov r25,r17
 613 03a4 0E94 0000 		call __gesf2
 614               	.LVL31:
 615 03a8 87FF      		sbrs r24,7
 616 03aa 00C0      		rjmp .L21
 617               		.loc 1 139 0 is_stmt 0 discriminator 1
 618 03ac 20E0      		ldi r18,0
 619 03ae 30E0      		ldi r19,0
 620 03b0 40E6      		ldi r20,lo8(96)
 621 03b2 51E4      		ldi r21,lo8(65)
 622 03b4 6E2D      		mov r22,r14
 623 03b6 7F2D      		mov r23,r15
 624 03b8 802F      		mov r24,r16
 625 03ba 912F      		mov r25,r17
 626 03bc 0E94 0000 		call __ltsf2
 627               	.LVL32:
 628 03c0 87FF      		sbrs r24,7
 629 03c2 00C0      		rjmp .L1
 630               	.L21:
 140:hero.c        **** 		hero->dy = 0;
 631               		.loc 1 140 0 is_stmt 1
 632 03c4 198A      		std Y+17,__zero_reg__
 633 03c6 1A8A      		std Y+18,__zero_reg__
 634 03c8 1B8A      		std Y+19,__zero_reg__
 635 03ca 1C8A      		std Y+20,__zero_reg__
 636               	.L1:
 637               	/* epilogue start */
 141:hero.c        **** 	}
 142:hero.c        **** 
 143:hero.c        **** }
 638               		.loc 1 143 0
 639 03cc DF91      		pop r29
 640 03ce CF91      		pop r28
 641               	.LVL33:
 642 03d0 1F91      		pop r17
 643 03d2 0F91      		pop r16
 644 03d4 FF90      		pop r15
 645 03d6 EF90      		pop r14
 646 03d8 DF90      		pop r13
 647 03da CF90      		pop r12
 648 03dc BF90      		pop r11
 649 03de AF90      		pop r10
 650 03e0 0895      		ret
 651               		.cfi_endproc
 652               	.LFE8:
 654               		.section	.text.start_hero,"ax",@progbits
 655               	.global	start_hero
 657               	start_hero:
 658               	.LFB7:
  25:hero.c        **** void start_hero() {
 659               		.loc 1 25 0
 660               		.cfi_startproc
 661 0000 CF93      		push r28
 662               	.LCFI10:
 663               		.cfi_def_cfa_offset 3
 664               		.cfi_offset 28, -2
 665 0002 DF93      		push r29
 666               	.LCFI11:
 667               		.cfi_def_cfa_offset 4
 668               		.cfi_offset 29, -3
 669 0004 CDB7      		in r28,__SP_L__
 670 0006 DEB7      		in r29,__SP_H__
 671               	.LCFI12:
 672               		.cfi_def_cfa_register 28
 673 0008 6897      		sbiw r28,24
 674               	.LCFI13:
 675               		.cfi_def_cfa_offset 28
 676 000a 0FB6      		in __tmp_reg__,__SREG__
 677 000c F894      		cli
 678 000e DEBF      		out __SP_H__,r29
 679 0010 0FBE      		out __SREG__,__tmp_reg__
 680 0012 CDBF      		out __SP_L__,r28
 681               	/* prologue: function */
 682               	/* frame size = 24 */
 683               	/* stack size = 26 */
 684               	.L__stack_usage = 26
  26:hero.c        **** 	byte bitmap_hero[] = {
 685               		.loc 1 26 0
 686 0014 80EE      		ldi r24,lo8(-32)
 687 0016 8E8B      		std Y+22,r24
 688 0018 90E4      		ldi r25,lo8(64)
 689 001a 9F8B      		std Y+23,r25
 690 001c 888F      		std Y+24,r24
 691               	.LVL34:
  37:hero.c        **** 	init_sprite( &hero, 38,28,hero_width,hero_height, bitmap_hero );
 692               		.loc 1 37 0
 693 001e 86E1      		ldi r24,lo8(22)
 694 0020 E82E      		mov r14,r24
 695 0022 F12C      		mov r15,__zero_reg__
 696 0024 EC0E      		add r14,r28
 697 0026 FD1E      		adc r15,r29
 698 0028 03E0      		ldi r16,lo8(3)
 699 002a 23E0      		ldi r18,lo8(3)
 700 002c 4CE1      		ldi r20,lo8(28)
 701 002e 66E2      		ldi r22,lo8(38)
 702 0030 CC24      		clr r12
 703 0032 C394      		inc r12
 704 0034 D12C      		mov r13,__zero_reg__
 705 0036 CC0E      		add r12,r28
 706 0038 DD1E      		adc r13,r29
 707 003a C601      		movw r24,r12
 708 003c 0E94 0000 		call init_sprite
 709               	.LVL35:
  38:hero.c        **** 	hero.dx = 1;
 710               		.loc 1 38 0
 711 0040 40E0      		ldi r20,0
 712 0042 50E0      		ldi r21,0
 713 0044 60E8      		ldi r22,lo8(-128)
 714 0046 7FE3      		ldi r23,lo8(63)
 715 0048 4E87      		std Y+14,r20
 716 004a 5F87      		std Y+15,r21
 717 004c 688B      		std Y+16,r22
 718 004e 798B      		std Y+17,r23
  39:hero.c        **** 	hero.dy = 0;
 719               		.loc 1 39 0
 720 0050 1A8A      		std Y+18,__zero_reg__
 721 0052 1B8A      		std Y+19,__zero_reg__
 722 0054 1C8A      		std Y+20,__zero_reg__
 723 0056 1D8A      		std Y+21,__zero_reg__
  41:hero.c        **** 	draw_sprite( &hero );
 724               		.loc 1 41 0
 725 0058 C601      		movw r24,r12
 726 005a 0E94 0000 		call draw_sprite
 727               	.LVL36:
  43:hero.c        **** 	int score_update = 0;
 728               		.loc 1 43 0
 729 005e 00E0      		ldi r16,0
 730 0060 10E0      		ldi r17,0
  42:hero.c        **** 	int zombie_update = 0;
 731               		.loc 1 42 0
 732 0062 E12C      		mov r14,__zero_reg__
 733 0064 F12C      		mov r15,__zero_reg__
 734               	.LVL37:
 735               	.L59:
 736               	.LBB37:
  45:hero.c        **** 		clear();
 737               		.loc 1 45 0
 738 0066 0E94 0000 		call clear
 739               	.LVL38:
  46:hero.c        **** 		screen_lines();
 740               		.loc 1 46 0
 741 006a 0E94 0000 		call screen_lines
 742               	.LVL39:
  47:hero.c        ****     	lives_setup();
 743               		.loc 1 47 0
 744 006e 0E94 0000 		call lives_setup
 745               	.LVL40:
  48:hero.c        ****     	score_setup();
 746               		.loc 1 48 0
 747 0072 0E94 0000 		call score_setup
 748               	.LVL41:
  54:hero.c        **** 		move_hero( &hero );
 749               		.loc 1 54 0
 750 0076 C601      		movw r24,r12
 751 0078 0E94 0000 		call move_hero
 752               	.LVL42:
  55:hero.c        **** 		draw_sprite (&hero );
 753               		.loc 1 55 0
 754 007c C601      		movw r24,r12
 755 007e 0E94 0000 		call draw_sprite
 756               	.LVL43:
  56:hero.c        **** 		if ( zombie_update == 10 ) {
 757               		.loc 1 56 0
 758 0082 2AE0      		ldi r18,10
 759 0084 E216      		cp r14,r18
 760 0086 F104      		cpc r15,__zero_reg__
 761 0088 01F4      		brne .L57
  57:hero.c        **** 			new_zombies_pos();
 762               		.loc 1 57 0
 763 008a 0E94 0000 		call new_zombies_pos
 764               	.LVL44:
  59:hero.c        **** 			zombie_update = 0;
 765               		.loc 1 59 0
 766 008e E12C      		mov r14,__zero_reg__
 767 0090 F12C      		mov r15,__zero_reg__
 768               	.LVL45:
 769               	.L57:
  61:hero.c        **** 		if ( score_update == 50 ) {
 770               		.loc 1 61 0
 771 0092 0233      		cpi r16,50
 772 0094 1105      		cpc r17,__zero_reg__
 773 0096 01F4      		brne .L58
  62:hero.c        **** 			update_score_time();
 774               		.loc 1 62 0
 775 0098 0E94 0000 		call update_score_time
 776               	.LVL46:
  63:hero.c        **** 			score_update = 0;
 777               		.loc 1 63 0
 778 009c 00E0      		ldi r16,0
 779 009e 10E0      		ldi r17,0
 780               	.LVL47:
 781               	.L58:
  65:hero.c        **** 		refresh();
 782               		.loc 1 65 0
 783 00a0 0E94 0000 		call refresh
 784               	.LVL48:
  66:hero.c        **** 		zombie_update++;
 785               		.loc 1 66 0
 786 00a4 8FEF      		ldi r24,-1
 787 00a6 E81A      		sub r14,r24
 788 00a8 F80A      		sbc r15,r24
 789               	.LVL49:
  67:hero.c        **** 		score_update++;
 790               		.loc 1 67 0
 791 00aa 0F5F      		subi r16,-1
 792 00ac 1F4F      		sbci r17,-1
 793               	.LVL50:
 794               	.LBB38:
 795               	.LBB39:
 796               		.loc 2 164 0
 797 00ae 9FEF      		ldi r25,lo8(159999)
 798 00b0 20E7      		ldi r18,hi8(159999)
 799 00b2 82E0      		ldi r24,hlo8(159999)
 800 00b4 9150      		1: subi r25,1
 801 00b6 2040      		sbci r18,0
 802 00b8 8040      		sbci r24,0
 803 00ba 01F4      		brne 1b
 804 00bc 00C0      		rjmp .
 805 00be 0000      		nop
 806 00c0 00C0      		rjmp .L59
 807               	.LBE39:
 808               	.LBE38:
 809               	.LBE37:
 810               		.cfi_endproc
 811               	.LFE7:
 813               	.global	py
 814               		.section .bss
 817               	py:
 818 0000 0000      		.zero	2
 819               	.global	px
 820               		.data
 823               	px:
 824 0000 0100      		.word	1
 825               		.text
 826               	.Letext0:
 827               		.file 3 "/usr/local/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 828               		.file 4 "../teensy_graphics/byte.h"
 829               		.file 5 "../teensy_graphics/sprite.h"
 830               		.file 6 "../teensy_graphics/ascii_font.h"
 831               		.file 7 "../teensy_graphics/graphics.h"
 832               		.file 8 "screen.h"
 833               		.file 9 "lives.h"
 834               		.file 10 "score.h"
 835               		.file 11 "zombies.h"
DEFINED SYMBOLS
                            *ABS*:00000000 hero.c
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:2      *ABS*:0000003e __SP_H__
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:3      *ABS*:0000003d __SP_L__
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:4      *ABS*:0000003f __SREG__
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:6      *ABS*:00000001 __zero_reg__
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:18     .text.move_hero:00000000 move_hero
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:823    .data:00000000 px
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:817    .bss:00000000 py
/var/folders/dz/7l40hrmj72997lgmj3pdxb_m0000gn/T//cc8xuD66.s:657    .text.start_hero:00000000 start_hero

UNDEFINED SYMBOLS
__eqsf2
__addsf3
__floatsisf
__gesf2
__ltsf2
init_sprite
draw_sprite
clear
screen_lines
lives_setup
score_setup
new_zombies_pos
update_score_time
refresh
__do_copy_data
__do_clear_bss
